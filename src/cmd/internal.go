// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: 2021-Present The Zarf Authors

// Package cmd contains the CLI commands for Zarf.
package cmd

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/defenseunicorns/pkg/helpers/v2"
	"github.com/spf13/cobra"
	"github.com/spf13/cobra/doc"
	"github.com/spf13/pflag"
	"github.com/zarf-dev/zarf/src/config/lang"
	"github.com/zarf-dev/zarf/src/internal/agent"
	"github.com/zarf-dev/zarf/src/internal/gitea"
	"github.com/zarf-dev/zarf/src/pkg/cluster"
	"github.com/zarf-dev/zarf/src/pkg/logger"
)

func newInternalCommand(rootCmd *cobra.Command) *cobra.Command {
	cmd := &cobra.Command{
		Use:    "internal",
		Hidden: true,
		Short:  lang.CmdInternalShort,
	}

	cmd.AddCommand(newInternalAgentCommand())
	cmd.AddCommand(newInternalHTTPProxyCommand())
	cmd.AddCommand(newInternalGenCliDocsCommand(rootCmd))
	cmd.AddCommand(newInternalCreateReadOnlyGiteaUserCommand())
	cmd.AddCommand(newInternalCreateArtifactRegistryTokenCommand())
	cmd.AddCommand(newInternalUpdateGiteaPVCCommand())
	cmd.AddCommand(newInternalIsValidHostnameCommand())
	cmd.AddCommand(newInternalCrc32Command())

	return cmd
}

type internalAgentOptions struct{}

func newInternalAgentCommand() *cobra.Command {
	o := &internalAgentOptions{}

	cmd := &cobra.Command{
		Use:   "agent",
		Short: lang.CmdInternalAgentShort,
		Long:  lang.CmdInternalAgentLong,
		RunE:  o.run,
	}

	return cmd
}

func (o *internalAgentOptions) run(cmd *cobra.Command, _ []string) error {
	cluster, err := cluster.NewCluster()
	if err != nil {
		return err
	}
	return agent.StartWebhook(cmd.Context(), cluster)
}

type internalHTTPProxyOptions struct{}

func newInternalHTTPProxyCommand() *cobra.Command {
	o := &internalHTTPProxyOptions{}

	cmd := &cobra.Command{
		Use:   "http-proxy",
		Short: lang.CmdInternalProxyShort,
		Long:  lang.CmdInternalProxyLong,
		RunE:  o.run,
	}

	return cmd
}

func (o *internalHTTPProxyOptions) run(cmd *cobra.Command, _ []string) error {
	cluster, err := cluster.NewCluster()
	if err != nil {
		return err
	}
	return agent.StartHTTPProxy(cmd.Context(), cluster)
}

type internalGenCliDocsOptions struct {
	rootCmd *cobra.Command
}

func newInternalGenCliDocsCommand(root *cobra.Command) *cobra.Command {
	// TODO(soltysh): ideally this should be replace with cmd.Root() call from cobra
	o := &internalGenCliDocsOptions{
		rootCmd: root,
	}

	cmd := &cobra.Command{
		Use:   "gen-cli-docs",
		Short: lang.CmdInternalGenerateCliDocsShort,
		RunE:  o.run,
	}

	return cmd
}

func (o *internalGenCliDocsOptions) run(_ *cobra.Command, _ []string) error {
	// Don't include the datestamp in the output
	o.rootCmd.DisableAutoGenTag = true

	resetStringFlags := func(cmd *cobra.Command) {
		cmd.Flags().VisitAll(func(flag *pflag.Flag) {
			if flag.Value.Type() == "string" {
				flag.DefValue = ""
			}
		})
	}

	for _, cmd := range o.rootCmd.Commands() {
		if cmd.Use == "tools" {
			for _, toolCmd := range cmd.Commands() {
				// If the command is a vendored command, add a dummy flag to hide root flags from the docs
				if checkVendorOnlyFromPath(toolCmd) {
					addHiddenDummyFlag(toolCmd, "log-level")
					addHiddenDummyFlag(toolCmd, "log-format")
					addHiddenDummyFlag(toolCmd, "architecture")
					addHiddenDummyFlag(toolCmd, "no-log-file")
					addHiddenDummyFlag(toolCmd, "no-progress")
					addHiddenDummyFlag(toolCmd, "zarf-cache")
					addHiddenDummyFlag(toolCmd, "tmpdir")
					addHiddenDummyFlag(toolCmd, "insecure")
					addHiddenDummyFlag(toolCmd, "no-color")
				}

				// Remove the default values from all of the helm commands during the CLI command doc generation
				if toolCmd.Use == "helm" || toolCmd.Use == "sbom" {
					toolCmd.PersistentFlags().VisitAll(func(flag *pflag.Flag) {
						if flag.Value.Type() == "string" {
							flag.DefValue = ""
						}
					})
					resetStringFlags(toolCmd)
					for _, subCmd := range toolCmd.Commands() {
						resetStringFlags(subCmd)
						for _, helmSubCmd := range subCmd.Commands() {
							resetStringFlags(helmSubCmd)
						}
					}
				}

				if toolCmd.Use == "monitor" {
					resetStringFlags(toolCmd)
				}

				if toolCmd.Use == "yq" {
					for _, subCmd := range toolCmd.Commands() {
						if subCmd.Name() == "shell-completion" {
							subCmd.Hidden = true
						}
					}
				}
			}
		}
	}

	if err := os.RemoveAll("./site/src/content/docs/commands"); err != nil {
		return err
	}
	if err := os.Mkdir("./site/src/content/docs/commands", 0775); err != nil {
		return err
	}

	var prependTitle = func(s string) string {
		fmt.Println(s)

		name := filepath.Base(s)

		// strip .md extension
		name = name[:len(name)-3]

		// replace _ with space
		title := strings.ReplaceAll(name, "_", " ")

		return fmt.Sprintf(`---
title: %s
description: Zarf CLI command reference for <code>%s</code>.
tableOfContents: false
---

<!-- Page generated by Zarf; DO NOT EDIT -->

`, title, title)
	}

	var linkHandler = func(link string) string {
		return "/commands/" + link[:len(link)-3] + "/"
	}

	return doc.GenMarkdownTreeCustom(o.rootCmd, "./site/src/content/docs/commands", prependTitle, linkHandler)
}

func addHiddenDummyFlag(cmd *cobra.Command, flagDummy string) {
	if cmd.PersistentFlags().Lookup(flagDummy) == nil {
		var dummyStr string
		cmd.PersistentFlags().StringVar(&dummyStr, flagDummy, "", "")
		err := cmd.PersistentFlags().MarkHidden(flagDummy)
		if err != nil {
			logger.From(cmd.Context()).Debug("Unable to add hidden dummy flag", "error", err)
		}
	}
}

type internalCreateReadOnlyGiteaUserOptions struct{}

func newInternalCreateReadOnlyGiteaUserCommand() *cobra.Command {
	o := &internalCreateReadOnlyGiteaUserOptions{}

	cmd := &cobra.Command{
		Use:   "create-read-only-gitea-user",
		Short: lang.CmdInternalCreateReadOnlyGiteaUserShort,
		Long:  lang.CmdInternalCreateReadOnlyGiteaUserLong,
		RunE:  o.run,
	}

	return cmd
}

func (o *internalCreateReadOnlyGiteaUserOptions) run(cmd *cobra.Command, _ []string) error {
	timeoutCtx, cancel := context.WithTimeout(cmd.Context(), cluster.DefaultTimeout)
	defer cancel()
	c, err := cluster.NewClusterWithWait(timeoutCtx)
	if err != nil {
		return err
	}
	state, err := c.LoadZarfState(cmd.Context())
	if err != nil {
		return err
	}
	tunnel, err := c.NewTunnel(cluster.ZarfNamespaceName, cluster.SvcResource, cluster.ZarfGitServerName, "", 0, cluster.ZarfGitServerPort)
	if err != nil {
		return err
	}
	_, err = tunnel.Connect(cmd.Context())
	if err != nil {
		return err
	}
	defer tunnel.Close()
	tunnelURL := tunnel.HTTPEndpoint()
	giteaClient, err := gitea.NewClient(tunnelURL, state.GitServer.PushUsername, state.GitServer.PushPassword)
	if err != nil {
		return err
	}
	err = tunnel.Wrap(func() error {
		err = giteaClient.CreateReadOnlyUser(cmd.Context(), state.GitServer.PullUsername, state.GitServer.PullPassword)
		if err != nil {
			return err
		}
		return nil
	})
	if err != nil {
		return err
	}
	return nil
}

type internalCreateArtifactRegistryTokenOptions struct{}

func newInternalCreateArtifactRegistryTokenCommand() *cobra.Command {
	o := &internalCreateArtifactRegistryTokenOptions{}

	cmd := &cobra.Command{
		Use:   "create-artifact-registry-token",
		Short: lang.CmdInternalArtifactRegistryGiteaTokenShort,
		Long:  lang.CmdInternalArtifactRegistryGiteaTokenLong,
		RunE:  o.run,
	}

	return cmd
}

func (o *internalCreateArtifactRegistryTokenOptions) run(cmd *cobra.Command, _ []string) error {
	timeoutCtx, cancel := context.WithTimeout(cmd.Context(), cluster.DefaultTimeout)
	defer cancel()
	c, err := cluster.NewClusterWithWait(timeoutCtx)
	if err != nil {
		return err
	}
	ctx := cmd.Context()
	state, err := c.LoadZarfState(ctx)
	if err != nil {
		return err
	}

	// If we are setup to use an internal artifact server, create the artifact registry token
	if state.ArtifactServer.IsInternal() {
		tunnel, err := c.NewTunnel(cluster.ZarfNamespaceName, cluster.SvcResource, cluster.ZarfGitServerName, "", 0, cluster.ZarfGitServerPort)
		if err != nil {
			return err
		}
		_, err = tunnel.Connect(cmd.Context())
		if err != nil {
			return err
		}
		defer tunnel.Close()
		tunnelURL := tunnel.HTTPEndpoint()
		giteaClient, err := gitea.NewClient(tunnelURL, state.GitServer.PushUsername, state.GitServer.PushPassword)
		if err != nil {
			return err
		}
		err = tunnel.Wrap(func() error {
			tokenSha1, err := giteaClient.CreatePackageRegistryToken(ctx)
			if err != nil {
				return fmt.Errorf("unable to create an artifact registry token for Gitea: %w", err)
			}
			state.ArtifactServer.PushToken = tokenSha1
			return nil
		})
		if err != nil {
			return err
		}
		if err := c.SaveZarfState(ctx, state); err != nil {
			return err
		}
	}
	return nil
}

type internalUpdateGiteaPVCOptions struct {
	rollback bool
}

func newInternalUpdateGiteaPVCCommand() *cobra.Command {
	o := &internalUpdateGiteaPVCOptions{}

	cmd := &cobra.Command{
		Use:   "update-gitea-pvc",
		Short: lang.CmdInternalUpdateGiteaPVCShort,
		Long:  lang.CmdInternalUpdateGiteaPVCLong,
		RunE:  o.run,
	}

	cmd.Flags().BoolVarP(&o.rollback, "rollback", "r", false, lang.CmdInternalFlagUpdateGiteaPVCRollback)

	return cmd
}

func (o *internalUpdateGiteaPVCOptions) run(cmd *cobra.Command, _ []string) error {
	ctx := cmd.Context()
	pvcName := os.Getenv("ZARF_VAR_GIT_SERVER_EXISTING_PVC")

	c, err := cluster.NewCluster()
	if err != nil {
		return err
	}
	// There is a possibility that the pvc does not yet exist and Gitea helm chart should create it
	helmShouldCreate, err := c.UpdateGiteaPVC(ctx, pvcName, o.rollback)
	if err != nil {
		logger.From(ctx).Warn("Unable to update the existing Gitea persistent volume claim", "error", err.Error())
	}
	fmt.Print(helmShouldCreate)
	return nil
}

type internalIsValidHostnameOptions struct{}

func newInternalIsValidHostnameCommand() *cobra.Command {
	o := &internalIsValidHostnameOptions{}

	cmd := &cobra.Command{
		Use:   "is-valid-hostname",
		Short: lang.CmdInternalIsValidHostnameShort,
		RunE:  o.run,
	}

	return cmd
}

func (o *internalIsValidHostnameOptions) run(_ *cobra.Command, _ []string) error {
	if valid := helpers.IsValidHostName(); !valid {
		hostname, err := os.Hostname()
		return fmt.Errorf("the hostname %s is not valid. Ensure the hostname meets RFC1123 requirements https://www.rfc-editor.org/rfc/rfc1123.html, error=%w", hostname, err)
	}
	return nil
}

type internalCrc32Options struct{}

func newInternalCrc32Command() *cobra.Command {
	o := &internalCrc32Options{}

	cmd := &cobra.Command{
		Use:     "crc32 TEXT",
		Aliases: []string{"c"},
		Short:   lang.CmdInternalCrc32Short,
		Args:    cobra.ExactArgs(1),
		Run:     o.run,
	}

	return cmd
}

func (o *internalCrc32Options) run(_ *cobra.Command, args []string) {
	text := args[0]
	hash := helpers.GetCRCHash(text)
	fmt.Printf("%d\n", hash)
}
