---
title: Zarf Principles
---

Zarf is a tool for secure software delivery, optimized for disconnected environments. To ensure that Zarf remains true to its mission and continues to provide value for its users, the following design principles serve as a framework for evaluating new features and capabilities.

## 1. Airgap-First Functionality
Zarf is designed for airgapped environments, meaning that all functionality should operate without requiring external dependencies. This includes:
- Ensuring that all packaged software and dependencies are self-contained.
- Avoiding reliance on external repositories or registries during runtime.
- Providing a seamless user experience for both online and offline operations.

## 2. Minimal and Secure Core Artifacts
The Zarf binary and init package must remain lightweight and secure while offering core functionality. Considerations include:
- Baking in only essential tools necessary for package management, deployment, and validation.
- Avoiding unnecessary bloat by carefully selecting embedded utilities.
- Ensuring security best practices, including dependency verification and signed releases.

## 3. Clear Scope Within Kubernetes Environments
Zarf operates in Kubernetes clusters but does not attempt to replace existing Kubernetes tooling. Instead, Zarf should:
- Focus on enabling package management and deployment in airgapped clusters.
- Complement, rather than compete with, Kubernetes-native solution (e.g., Helm, Kustomize, and Operator patterns).
- Align with familiar user and developer workflows rather than inventing new paradigms, unless solving a gap unique to Zarf.
- Facilitate cluster initialization and ongoing software management without enforcing opinionated infrastructure choices.

## 4. Declarative and Reproducible Workflows
To maintain consistency in deployments, Zarf should emphasize:
- Declarative package definitions that allow for repeatable deployments.
- Versioned and auditable package formats that ensure integrity across different environments.
- Support for GitOps workflows where applicable.

## 5. Operational Simplicity
Zarf should remain simple to use and operationalize, with considerations such as:
- Clear and concise configuration files that reduce complexity.
- A user-friendly CLI that abstracts away unnecessary details while allowing expert-level control when needed.
- Automation and scripting capabilities that streamline usage in constrained environments.
- Enhancements that support developer workflows by simplifying common or complex tasks.

## 6. Compatibility and Extensibility
Zarf should be flexible enough to work in various environments while maintaining its core mission. This means:
- Supporting multiple architectures and operating systems where feasible.
- Enabling custom Init/Package configuration to reduce/expand scope for user constraints. 
- Allowing extensibility through SDK integrations.
- Ensuring compatibility with industry standards to facilitate interoperability.

## 7. Community and Open Source Focus
As an open-source project, Zarf should prioritize community involvement and transparency by:
- Encouraging feedback and contributions from users and maintainers.
- Providing clear documentation and guidance for adoption.
- Adhering to open governance principles to guide long-term sustainability.

These principles help guide the evolution of Zarf while ensuring that new features and capabilities align with its core mission. By adhering to these guidelines, Zarf can continue to serve as a robust, reliable tool for software delivery.
