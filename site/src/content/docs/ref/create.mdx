---
title: Create a Package
sidebar:
  order: 60
---

import Mermaid from "@components/Mermaid.astro";
import Details from "@components/Details.astro";

The following diagram shows the order of operations for the `zarf package create` command and the hook locations for [actions](/ref/actions).

<Details label="Lifecycle Diagram">
<Mermaid diagram={`

%%{ init: {
  flowchart: { nodeSpacing: 50, rankSpacing: 60 },
  themeVariables: { fontSize: '14px', textMargin: 8 }
} }%%

flowchart TB
  %%=== Setup phase ===%%
  subgraph Setup
    direction TB
    A1[Set working directory] --> A2[Parse zarf.yaml]
    A2 --> A3[Filter components by architecture]
    A3 --> A4[Detect init package]
    A4 --> A5[Handle deprecations]
    A5 --> A6[Parse component imports]
    A6 --> A7[Process create-time variables]
    A7 --> A8[Write build data & zarf.yaml]
  end

  %%=== Validation gate ===%%
  A8 --> V1{Run validations pass?}
  V1 -->|No| Abort[Abort]:::fail
  V1 -->|Yes| I1

  %%=== Init package choice ===%%
  subgraph "Init Package"
    direction TB
    I1{Init package?}
    I1 -->|Yes| I2[Add seed image]
    I1 -->|No|  I2
    I2 --> C1
  end

  %%=== OnCreate actions ===%%
  subgraph "OnCreate Actions"
    direction TB
    C1[Add each component] --> C2[Before onCreate]:::action
    C2 --> C3[Load .charts]
    C3 --> C4[Load .files]
    C4 --> C5[Load .dataInjections]
    C5 --> C6[Load .manifests]
    C6 --> C7[Load .repos]
    C7 --> C8[After onCreate]:::action
    C8 --> S1{Success?}
    S1 -->|Yes| S2[onCreate.success]:::action
    S1 -->|No| S3[onCreate.failure]:::action --> Abort
  end

  %%=== Finalize package ===%%
  subgraph "Finalize"
    direction TB
    S2 --> F1[Load all .images]
    F1 --> F2{Skip SBOM?}
    F2 -->|No| F3[Generate SBOM] --> F4
    F2 -->|Yes| F4[Reset working directory]
    F4 --> F5[Create package archive]
    F5 --> M1{Is multipart?}
    M1 -->|Yes| M2[Split archive] --> F6[Handle sbom view/out flags]
    M1 -->|No|  F6
  end

  classDef prompt fill:#4adede,color:#000000
  classDef action fill:#bd93f9,color:#000000
  classDef fail   fill:#aa0000
`}/>
</Details>


## Package Templates

Package configuration templates can be used during `zarf package create` to configure the `zarf.yaml` file. Templates are baked into the Zarf package so they cannot be changed post create.

:::caution

`zarf package create` templates only template `###ZARF_PKG_TMPL_*###` entries the `zarf.yaml` file while `zarf package deploy` only templates other `manifests`, `charts`, `files`, and `actions`.  To learn more about using deployment values see the [Deployment Values](/ref/values) page.

:::

You can specify `zarf.yaml` templates at package create time by including `###_ZARF_PKG_TMPL_*###` as the value for any string-type data in your package definition. Template values can be defined using [config files](/ref/config-files/) or the `--set` flag. If a template is undefined during `zarf package create` if will always be prompted for unless `--confirm` is used.

An example of templates is below:
```yaml
kind: ZarfPackageConfig
metadata:
  name: 'pkg-variables'
  description: 'Prompt for a variables during package create'

constants:
  - name: PROMPT_IMAGE
    value: '###ZARF_PKG_TMPL_PROMPT_ON_CREATE###'

components:
  - name: zarf-prompt-image
    required: true
    images:
      - '###ZARF_PKG_TMPL_PROMPT_ON_CREATE###'
```

:::caution

It is not recommended to use package configuration templates for any `sensitive` data as this will be baked into the package as plain text.  Please use a deploy-time variable with the `sensitive` key set instead.

:::

:::note

You can only template string values in this way as non-string values will not marshal/unmarshal properly through the yaml.

Additionally, you cannot template the component import path using package configuration templates

:::
