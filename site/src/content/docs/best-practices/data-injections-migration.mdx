---
title: "Migrate From Data injections"
---

This guide explains how to migrate your Zarf deployment from the data injections feature to OCI image-based data delivery methods. Data injections are deprecated in the current Zarf schema version and will be fully removed in the next schema version. There are several reasons behind this:

- **Poor User Experience**: Many users have struggled to figure out how to adopt data injections.
- **Host dependency**: Data injections shell out to `tar`. This makes testing difficult and introduces differences across environments.
- **Ephemeral Storage**: Because Data Injections only load data during `zarf package deploy` the data must be saved to persistent storage. Otherwise, when a pod restarts any data injected will be lost.
- **Better alternatives**: OCI images provide a Kubernetes native solution for data delivery, and neatly fit into the Zarf delivery paradigm.

## Migration guide

There are two recommended approaches to replacing data injections.

The first, and preferred approach, is the Kubernetes Feature, [read-only OCI based volumes](https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/4639-oci-volume-source). This feature is generally available as of Kubernetes 1.35 and compatible with the Zarf agent as of v0.69.1. It provides a direct path for consuming container images as read only data sources.

The second approach uses init containers to migrate data to volumes. This approach has been widely adopted among Kubernetes users for years. It involves spinning up an init container from an OCI image that holds the required data. This data is then persisted to a common volume which the long running container(s) in the pod can use.

Migration for both of these approaches will require packaging an OCI image. Their implementation will differ in the pod specification.

### Step 1: Package Your Data in an OCI Image

First, create a container image containing your data:

```dockerfile
FROM alpine:3.18
COPY your-data-file /your-data/your-data-file
```

Build and push this image:
```bash
docker build -t your-registry/your-data:tag .
docker push your-registry/your-data:tag
```

:::tip

Some registries will not accept images over a certain size or you may want to avoid pushing your data to a connected registry. To build the package with a local image use [Image Archives](/ref/components#container-image-archives). The [Kiwix example](/ref/examples/kiwix) utilizes this strategy

:::

### Step 2: Update zarf.yaml

**Before (Data Injections):**
```yaml
kind: ZarfPackageConfig
metadata:
  name: data-injections
components:
  - name: my-app
    required: true
    images:
      - ghcr.io/my-app:1.0.0
      - alpine:3.18
    dataInjections:
      - source: my-folder
        target:
          namespace: my-app
          selector: app=my-app
          container: data-loader
          path: /data
        compress: true
```

**After (Init Container Strategy):**
```yaml
kind: ZarfPackageConfig
metadata:
  name: init-data-loading
components:
  - name: my-app
    required: true
    images:
      - ghcr.io/my-app:1.0.0
      - your-registry/your-data:tag  # Your container with your data file
```

Rather than storing the data in the package through data injections, the data is stored in the `your-registry/your-data:tag` container.

### Read-Only Volume Approach

### Step 3a: Update Deployment Manifest

**Before (Data Injections):**
```yaml
spec:
  template:
    spec:
      initContainers:
        - name: data-injector
          image: alpine:3.18
          command: ["sh", "-c"]
          args:
            - 'while [ ! -f /data/###ZARF_DATA_INJECTION_MARKER### ]; do echo "waiting for zarf data sync" && sleep 1; done; echo "we are done waiting!"'
          volumeMounts:
            - mountPath: /data
              name: data
      containers:
        - name: my-app
          image: "ghcr.io/my-app:1.0.0"
          command:
            [
              "sh",
              "-c",
              "ls -la /data", # This will list all files copied by data injections
            ]
          volumeMounts:
            - mountPath: /data
              name: data
      volumes:
        - name: data
          persistentVolumeClaim:
            claimName: my-data
```

**After (Read-Only OCI Volume Strategy):**

```yaml
spec:
  template:
    spec:
      containers:
        - name: kiwix-serve
          image: "ghcr.io/my-app:1.0.0"
          command:
            [
              "sh",
              "-c",
              "ls -la /mount-path", # This will list all files in the base directory of the your-registry/your-data:tag image.
            ]
          ...
          volumeMounts:
            - name: data
              mountPath: /mount-path
      volumes:
        - name: data
          image:
            reference: your-registry/your-data:tag
```

This method reduces the surface area of image execution and speeds up the process by directly mounting the data in place rather than copying it from an init container to another volume.

### Init Container Approach

### Step 3b: Update Deployment Manifest

**Before (Data Injections):**
```yaml
spec:
  template:
    spec:
      initContainers:
        - name: data-injector
          image: alpine:3.18
          command: ["sh", "-c"]
          args:
            - 'while [ ! -f /data/###ZARF_DATA_INJECTION_MARKER### ]; do echo "waiting for zarf data sync" && sleep 1; done; echo "we are done waiting!"'
          volumeMounts:
            - mountPath: /data
              name: data
      containers:
        - name: my-app
          image: "ghcr.io/my-app:1.0.0"
          command:
            [
              "sh",
              "-c",
              "ls -la /data", # This will list all files added to this directory through data injections
            ]
          volumeMounts:
            - mountPath: /data
              name: data
      volumes:
        - name: data
          persistentVolumeClaim:
            claimName: my-data
```

**After (Init Container Strategy):**
```yaml
spec:
  template:
    spec:
      initContainers:
        - name: data-loader
          image: your-registry/your-data:tag
          command: ["sh", "-c"]
          args:
            - |
              cp /your-data/your-data-file /data/my-app-data-location
          volumeMounts:
            - mountPath: /data
              name: data
      containers:
        - name: my-app
          image: "ghcr.io/my-app:1.0.0"
          command:
            [
              "sh",
              "-c",
              "ls -la /data/my-app-data-location", # This will list all files copied during the init container run
            ]
          volumeMounts:
            - mountPath: /data
              name: data
      volumes:
        - name: data
          emptyDir: {}
```

With the image-based approach, data can use ephemeral storage, such as emptyDir, since the init container repopulates the data from the container image on each pod restart.

## Need Help?

If there are any reasons that these methods do not work for you, please comment in issue [#3926](https://github.com/zarf-dev/zarf/issues/3926)
