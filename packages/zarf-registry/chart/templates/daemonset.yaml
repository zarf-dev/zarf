{{ if eq .Values.service.registryProxy "true" }}
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: zarf-registry-proxy
spec:
  selector:
    matchLabels:
      app: zarf-registry-proxy
  template:
    metadata:
      labels:
        app: zarf-registry-proxy
        # Don't mutate this pod
        zarf.dev/agent: ignore
    spec:
      containers:
        - args:
          {{ if eq .Values.service.ipv6Only "true" }}
            - tcp6-listen:{{ .Values.service.nodePort }},bind=[::1],reuseaddr,fork
            - tcp6:{{ template "docker-registry.fullname" . }}:5000
          {{- else }}
          - TCP4-LISTEN:31999,reuseaddr,fork
          - OPENSSL:{{ template "docker-registry.fullname" . }}:5000,cert=/certs/client/tls.crt,key=/certs/client/tls.key,cafile=/certs/ca/ca.pem,verify=1
          {{- end }}
          image: "{{ .Values.proxy.image.repository }}:{{ .Values.proxy.image.tag }}"
          imagePullPolicy: IfNotPresent
          name: zarf-registry-proxy
          volumeMounts:
          - name: proxy-certs
            mountPath: /certs/client
            readOnly: true
          - name: ca-cert
            mountPath: /certs/ca
            readOnly: true
          ports:
            - containerPort: {{ .Values.service.nodePort }}
            {{ if ne .Values.service.ipv6Only "true" }}
              hostPort: {{ .Values.service.nodePort }}
              hostIP: "127.0.0.1"
            {{- end }}
          resources:
            limits:
              cpu: 100m
              memory: 200Mi
            requests:
              cpu: 100m
              memory: 200Mi
      volumes:
        - name: proxy-certs
          secret:
            secretName: zarf-registry-proxy-tls
        - name: ca-cert
          secret:
            secretName: zarf-registry-ca
    # IPV6 does not support rewriting packets to localhost so it needs to use host network over hostport
    {{ if eq .Values.service.ipv6Only "true" }}
      dnsPolicy: ClusterFirstWithHostNet
      hostNetwork: true
    {{- end }}
{{- end }}
