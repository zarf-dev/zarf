{{ if eq .Values.service.registryProxy "true" }}
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: zarf-registry-proxy
spec:
  selector:
    matchLabels:
      app: zarf-registry-proxy
  template:
    metadata:
      labels:
        app: zarf-registry-proxy
        # Don't mutate this pod
        zarf.dev/agent: ignore
    spec:
      containers:
        - args:
          {{ if eq .Values.service.ipv6Only "true" }}
            - tcp6-listen:{{ .Values.service.nodePort }},bind=[::1],reuseaddr,fork
            - tcp6:{{ template "docker-registry.fullname" . }}:5000
          {{- else }}
            - tcp4-listen:{{ .Values.service.nodePort }},reuseaddr,fork
            - tcp4:{{ template "docker-registry.fullname" . }}:5000
          {{- end }}
          image: "{{ .Values.proxy.image.repository }}:{{ .Values.proxy.image.tag }}"
          imagePullPolicy: IfNotPresent
          name: zarf-registry-proxy
          ports:
            - containerPort: {{ .Values.service.nodePort }}
            {{ if ne .Values.service.ipv6Only "true" }}
              hostPort: {{ .Values.service.nodePort }}
              hostIP: "127.0.0.1"
            {{- end }}
          resources:
            limits:
              cpu: 100m
              memory: 200Mi
            requests:
              cpu: 100m
              memory: 200Mi
        # FIXME: I tried to make this a sidecar init container, but it doesn't work as an init container. I may want to make this it's own daemonset
        - name: injector
          image: "{{ .Values.proxy.injector.image }}"
          workingDir: /zarf-init
          command: ["/zarf-init/zarf-injector", "{{ .Values.proxy.injector.shasum }}"]
          ports:
            - containerPort: 5000
              hostPort: 5000
              hostIP: 127.0.0.1
          readinessProbe:
            failureThreshold: 10
            httpGet:
              path: /v2/
              port: 5000
              scheme: HTTP
            periodSeconds: 2
            successThreshold: 1
            timeoutSeconds: 1
          volumeMounts:
            - mountPath: /zarf-init/zarf-injector
              name: init
              subPath: zarf-injector
            - mountPath: /zarf-seed
              name: seed
            {{- range $i := until (int .Values.proxy.injector.payLoadConfigMapAmount) }}
            - mountPath: /zarf-init/zarf-payload-{{ printf "%03d" $i }}
              name: zarf-payload-{{ printf "%03d" $i }}
              subPath: zarf-payload-{{ printf "%03d" $i }}
            {{- end }}
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
              - ALL
            readOnlyRootFilesystem: true
            runAsNonRoot: true
    # IPV6 does not support rewriting packets to localhost so it needs to use host network over hostport
    {{ if eq .Values.service.ipv6Only "true" }}
      dnsPolicy: ClusterFirstWithHostNet
      hostNetwork: true
    {{- end }}
      securityContext:
        fsGroup: 2000
        runAsGroup: 2000
        runAsUser: 1000
        seccompProfile:
          type: RuntimeDefault
      volumes:
        - configMap:
            defaultMode: 511
            name: rust-binary
          name: init
        - emptyDir: {}
          name: seed
        {{- range $i := until (int .Values.proxy.injector.payLoadConfigMapAmount) }}
        - configMap:
            defaultMode: 420
            name: zarf-payload-{{ printf "%03d" $i }}
          name: zarf-payload-{{ printf "%03d" $i }}
        {{- end }}
{{- end }}
